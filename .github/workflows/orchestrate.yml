name: CI/CD Pipeline

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Pipeline modes:
#   Push â†’ *-dev             âžœ  create PR to int-agentic (lightweight)
#   PR â†’ int-agentic         âžœ  full deploy + test MERGE COMMIT â†’ auto-merge
#   PR â†’ main                âžœ  tests-only (validate against existing env)
#   Push â†’ main              âžœ  full deploy to production
#   Manual dispatch          âžœ  full deploy (chosen environment)
#
# Promotion flow:
#   *-dev push â†’ creates PR to int-agentic
#   PR to int-agentic â†’ deploys MERGE COMMIT â†’ tests â†’ auto-merge if pass
#   int-agentic push â†’ promote-to-main.yml â†’ creates/updates PR to main
#   main PR â†’ human review + tests-only â†’ merge â†’ full deploy to production
#
# Key design: PRs to int-agentic build from the GitHub merge commit,
# which combines the dev branch with int-agentic. This ensures we test
# the MERGED result, not the dev branch in isolation.
#
# Per-developer environments:
#   Each developer pushes to their own <name>-dev branch.
#   The pipeline maps <name>-dev â†’ integration-<name> environment,
#   which contains that developer's own Azure subscription credentials.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

on:
  workflow_dispatch:
    inputs:
      target_env:
        type: string
        description: "Environment to deploy (e.g. integration-james, production)"
        required: true

  pull_request:
    branches:
      - int-agentic
      - main
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
      - 'LICENSE'
      - '.github/workflows/readme.md'

  push:
    branches:
      - main
      - '*-dev'
    paths-ignore:
      - '**/*.md'
      - 'docs/**'
      - 'LICENSE'
      - '.github/workflows/readme.md'

permissions:
  contents: write
  pull-requests: write
  id-token: write


jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Step 0: Determine pipeline mode and target environment
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  pipeline-config:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.config.outputs.environment }}
      full_deploy: ${{ steps.config.outputs.full_deploy }}
      create_pr_only: ${{ steps.config.outputs.create_pr_only }}
    steps:
      - name: Determine pipeline mode
        id: config
        run: |
          EVENT="${{ github.event_name }}"
          CREATE_PR_ONLY="false"

          # â”€â”€ Resolve target environment â”€â”€
          if [ "$EVENT" = "workflow_dispatch" ]; then
            ENV="${{ inputs.target_env }}"
          elif [ "$EVENT" = "pull_request" ]; then
            case "${{ github.base_ref }}" in
              main)
                ENV="production" ;;
              int-agentic)
                # PR to int-agentic: extract dev name from head branch
                HEAD="${{ github.head_ref }}"
                case "$HEAD" in
                  *-dev)
                    DEV_NAME="${HEAD%-dev}"
                    ENV="integration-${DEV_NAME}" ;;
                  *)
                    ENV="integration" ;;
                esac ;;
              *)
                ENV="integration" ;;
            esac
          elif [ "$EVENT" = "push" ]; then
            BRANCH="${{ github.ref_name }}"
            case "$BRANCH" in
              main)
                ENV="production" ;;
              *-dev)
                # Dev push: only create PR to int-agentic, no deploy
                DEV_NAME="${BRANCH%-dev}"
                ENV="integration-${DEV_NAME}"
                CREATE_PR_ONLY="true" ;;
              *)
                ENV="integration" ;;
            esac
          else
            ENV="integration"
          fi

          # â”€â”€ Resolve pipeline mode â”€â”€
          if [ "$CREATE_PR_ONLY" = "true" ]; then
            FULL_DEPLOY="false"
          elif [ "$EVENT" = "pull_request" ] && [ "${{ github.base_ref }}" = "main" ]; then
            # PRs to main: tests-only against existing environment
            FULL_DEPLOY="false"
          elif [ "$EVENT" = "pull_request" ] && [ "${{ github.base_ref }}" = "int-agentic" ]; then
            # PRs to int-agentic: FULL deploy from merge commit
            FULL_DEPLOY="true"
          elif [ "$EVENT" = "push" ]; then
            FULL_DEPLOY="true"
          else
            FULL_DEPLOY="true"
          fi

          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "full_deploy=$FULL_DEPLOY" >> $GITHUB_OUTPUT
          echo "create_pr_only=$CREATE_PR_ONLY" >> $GITHUB_OUTPUT
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "Event:          $EVENT"
          echo "Environment:    $ENV"
          echo "Full deploy:    $FULL_DEPLOY"
          echo "Create PR only: $CREATE_PR_ONLY"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Step 0.5: Create PR to int-agentic (*-dev push only)
  #   When a developer pushes to their *-dev branch, we just create
  #   (or update) a PR to int-agentic. The PR triggers the full pipeline
  #   which builds from the MERGE COMMIT, testing combined code.
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  create-pr:
    needs: pipeline-config
    if: needs.pipeline-config.outputs.create_pr_only == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Create or update PR to int-agentic
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          BRANCH="${{ github.ref_name }}"
          echo "ðŸ” Checking for existing PR: ${BRANCH} â†’ int-agentic"

          EXISTING_PR=$(gh pr list \
            --repo "${{ github.repository }}" \
            --base int-agentic \
            --head "$BRANCH" \
            --state open \
            --json number \
            --jq '.[0].number // empty')

          if [ -n "$EXISTING_PR" ]; then
            echo "âœ… PR #${EXISTING_PR} already exists â€” push updated it"
            echo "   The PR-triggered pipeline will run with the updated merge commit"
          else
            echo "ðŸ“ Creating PR: ${BRANCH} â†’ int-agentic"
            gh pr create \
              --repo "${{ github.repository }}" \
              --base int-agentic \
              --head "$BRANCH" \
              --title "Merge ${BRANCH} into int-agentic" \
              --body "Auto-created by CI/CD pipeline.

          This PR will be automatically merged after the pipeline validates
          the **merge commit** (${BRANCH} + int-agentic combined).

          Pipeline run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            echo "âœ… PR created â€” full pipeline will trigger on the new PR"
          fi

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Step 1: Preflight â€“ unlock Terraform state storage (full deploy only)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  preflight:
    needs: pipeline-config
    if: needs.pipeline-config.outputs.full_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.pipeline-config.outputs.environment }}
    steps:
      - name: Azure OIDC Login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - run: |
          echo "Preflight: ensuring Terraform state storage is accessible"
          if az group show --name "$TFSTATE_RG" > /dev/null 2>&1; then
            az storage account update --resource-group "$TFSTATE_RG" --name "$TFSTATE_ACCOUNT" --default-action Allow
            az storage account update --resource-group "$TFSTATE_RG" --name "$TFSTATE_ACCOUNT" --public-network-access Enabled
          else
            echo "::warning::Terraform state resource group '${TFSTATE_RG}' not found - skipping"
          fi
        env:
          TFSTATE_RG: ${{ vars.TFSTATE_RG }}
          TFSTATE_ACCOUNT: ${{ vars.TFSTATE_ACCOUNT }}

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Step 2: Deploy infrastructure (full deploy only)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-infrastructure:
    needs: [pipeline-config, preflight]
    if: needs.pipeline-config.outputs.full_deploy == 'true'
    uses: ./.github/workflows/infrastructure.yml
    with:
      environment: ${{ needs.pipeline-config.outputs.environment }}
    secrets: inherit

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Step 3: Build containers (full deploy only)
  #   For PRs to int-agentic, actions/checkout gets the MERGE COMMIT
  #   so Docker images contain dev changes + int-agentic combined.
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  build-application-container:
    needs: [pipeline-config, deploy-infrastructure]
    if: needs.pipeline-config.outputs.full_deploy == 'true'
    uses: ./.github/workflows/docker-application.yml
    with:
      environment: ${{ needs.pipeline-config.outputs.environment }}
    secrets: inherit

  build-mcp-container:
    needs: [pipeline-config, deploy-infrastructure]
    if: needs.pipeline-config.outputs.full_deploy == 'true'
    uses: ./.github/workflows/docker-mcp.yml
    with:
      environment: ${{ needs.pipeline-config.outputs.environment }}
    secrets: inherit

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Step 4: Update Container Apps with new images (full deploy only)
  #   Uses SHA-tagged images to force new Container App revisions.
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  update-containers:
    needs: [pipeline-config, build-application-container, build-mcp-container]
    if: >-
      always()
      && needs.pipeline-config.outputs.full_deploy == 'true'
      && (needs.build-application-container.result == 'success' || needs.build-mcp-container.result == 'success')
    uses: ./.github/workflows/update-containers.yml
    with:
      environment: ${{ needs.pipeline-config.outputs.environment }}
      mcp_image_tag: ${{ github.sha }}
      backend_image_tag: ${{ github.sha }}
    secrets: inherit

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Resolve endpoints from existing environment (PR â†’ main tests-only)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  resolve-endpoints:
    needs: pipeline-config
    if: >-
      needs.pipeline-config.outputs.full_deploy == 'false'
      && needs.pipeline-config.outputs.create_pr_only == 'false'
    runs-on: ubuntu-latest
    environment: ${{ needs.pipeline-config.outputs.environment }}
    outputs:
      backend_endpoint: ${{ steps.lookup.outputs.backend_endpoint }}
      mcp_endpoint: ${{ steps.lookup.outputs.mcp_endpoint }}
      deployed: ${{ steps.lookup.outputs.deployed }}
    steps:
      - name: Azure OIDC Login
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Look up Container App endpoints
        id: lookup
        run: |
          PROJECT="${{ vars.PROJECT_NAME || 'OpenAIWorkshop' }}"
          ENV="${{ needs.pipeline-config.outputs.environment }}"
          ITERATION="${{ vars.ITERATION || '002' }}"
          RG="rg-${PROJECT}-${ENV}-${ITERATION}"

          BE_FQDN=$(az containerapp show \
            --name "ca-be-${ITERATION}" \
            --resource-group "$RG" \
            --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || echo "")

          MCP_FQDN=$(az containerapp show \
            --name "ca-mcp-${ITERATION}" \
            --resource-group "$RG" \
            --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || echo "")

          if [ -n "$BE_FQDN" ]; then
            echo "backend_endpoint=https://${BE_FQDN}" >> $GITHUB_OUTPUT
            echo "deployed=true" >> $GITHUB_OUTPUT
          else
            echo "::warning::Backend not found in $RG"
            echo "backend_endpoint=" >> $GITHUB_OUTPUT
            echo "deployed=false" >> $GITHUB_OUTPUT
          fi
          echo "mcp_endpoint=${MCP_FQDN:+https://$MCP_FQDN}" >> $GITHUB_OUTPUT

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Step 5: Run integration tests
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  integration-tests:
    needs: [pipeline-config, deploy-infrastructure, update-containers, resolve-endpoints]
    if: >-
      always() && (
        needs.update-containers.result == 'success'
        || (needs.resolve-endpoints.result == 'success' && needs.resolve-endpoints.outputs.deployed == 'true')
      )
    uses: ./.github/workflows/integration-tests.yml
    with:
      environment: ${{ needs.pipeline-config.outputs.environment }}
      backend_endpoint: ${{ needs.deploy-infrastructure.outputs.backend_endpoint || needs.resolve-endpoints.outputs.backend_endpoint }}
      mcp_endpoint: ${{ needs.deploy-infrastructure.outputs.mcp_endpoint || needs.resolve-endpoints.outputs.mcp_endpoint }}
      mcp_internal_only: true
    secrets: inherit

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Step 6: Agent quality evaluation (full deploy only)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  agent-evaluation:
    needs: [pipeline-config, deploy-infrastructure, update-containers, integration-tests]
    if: >-
      always()
      && needs.pipeline-config.outputs.full_deploy == 'true'
      && needs.integration-tests.result == 'success'
    uses: ./.github/workflows/agent-evaluation.yml
    with:
      environment: ${{ needs.pipeline-config.outputs.environment }}
      backend_endpoint: ${{ needs.deploy-infrastructure.outputs.backend_endpoint }}
      eval_limit: 5
    secrets: inherit

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Step 7: Auto-merge PR into int-agentic
  #   After successful tests on the MERGE COMMIT, merge the PR.
  #   Uses GH_PAT so the push triggers promote-to-main.yml.
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  auto-merge:
    needs: [pipeline-config, integration-tests, agent-evaluation]
    if: >-
      always()
      && needs.pipeline-config.outputs.full_deploy == 'true'
      && needs.integration-tests.result == 'success'
      && (needs.agent-evaluation.result == 'success' || needs.agent-evaluation.result == 'skipped')
      && github.event_name == 'pull_request'
      && github.base_ref == 'int-agentic'
    runs-on: ubuntu-latest
    steps:
      - name: Auto-merge PR into int-agentic
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          PR_NUMBER="${{ github.event.pull_request.number }}"
          echo "âœ… Tests passed on merge commit â€” auto-merging PR #${PR_NUMBER}"
          gh pr merge "$PR_NUMBER" \
            --repo "${{ github.repository }}" \
            --squash \
            --auto \
            --subject "chore: merge ${{ github.head_ref }} into int-agentic (auto)" \
            --body "Auto-merged after successful CI/CD pipeline run ${{ github.run_id }}"
          echo "âœ… PR #${PR_NUMBER} merge initiated"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Step 8: Auto-destroy dev environment after successful merge
  #   Dev environments are ephemeral â€” tear down after merge.
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  auto-destroy:
    needs: [pipeline-config, auto-merge]
    if: >-
      always()
      && needs.auto-merge.result == 'success'
      && github.event_name == 'pull_request'
      && github.base_ref == 'int-agentic'
    uses: ./.github/workflows/destroy.yml
    with:
      environment: ${{ needs.pipeline-config.outputs.environment }}
    secrets: inherit
